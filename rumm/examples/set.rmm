// Load the main set.mm database
load "examples/examples.mm"

// Fetch hypotheses from the hypothesis or the 'antecedent' part of the goal
tactics deduction ()
{ try
	!
	{ match goal
		$ ( &W1 -> ( &W2 /\ &W3 ) ) $
		{ apply ~jca { use deduction } { use deduction } }
		$ ( &W1 -> ( &W2 /\ &W3 /\ &W4 ) ) $
		{ apply ~3jca { use deduction } { use deduction } { use deduction } }
	}
	{ apply ~id }
	{ apply ~a1i ! }
	{ apply ~simpr }
	{ apply ~simpl }
	{ apply ~simplr }
	{ apply ~simpll }
	{ apply ~simpllr }
	{ apply ~simplll }
	{ apply ~simp-4r }
	{ apply ~simp-4l }
	{ apply ~simp-5r }
	{ apply ~simp-5l }

	{ match goal
		$ ( ph -> &C1 e. ( &C2 ^m &C3 ) ) $ { subgoal 
			{ use deduction } 
			$ ( ph -> &C1 : &C3 --> &C2 ) 
			$ { apply ~mpbird 
				{ use deduction }
				{ apply ~elmapd { use existence } { use existence } with ~cV $ _V $ ~cW $ _V $ }
				with ~wch $ &C1 : &C3 --> &C2 $ 
			}
		}
	}
}

// First put the antecedent in a normal form then apply the given tactics
tactics normalize ( @T )
{ match goal
	$ ( ( ph /\ ps /\ ch ) -> th ) $
	{ apply ~sylbir { apply ~df-3an } { use normalize @T } with ~wps $ ( ( ph /\ ps ) /\ ch ) $ }
	$ ( ( ph /\ ( ps /\ ch ) ) -> th ) $
	{ apply ~anasss { use normalize @T } }
	$ ( ( ( ph /\ ( ps /\ ch ) ) /\ th ) -> et ) $
	{ apply ~sylbir { apply ~anbi1i { apply ~anass } } { use normalize @T } with ~wps $ ( ( ( ph /\ ps ) /\ ch ) /\ th ) $ }
	$ ( ( ph /\ ( ps /\ ch /\ th ) ) -> et ) $
	{ apply ~3imp2 { apply ~exp41 { use normalize @T  } } }
	$ ( ph -> ps ) $
	@T
}

tactics equality ()
{ try
	{ use deduction }
	{ apply ~eqidd }
	{ match goal
		$ ( ph -> ( ( ps /\ th ) <-> ( ch /\ ta ) ) ) $ { apply ~anbi12d { use equality } { use equality } }
		$ ( ph -> ( ( ps \/ th ) <-> ( ch \/ ta ) ) ) $ { apply ~orbi12d { use equality } { use equality } }
		$ ( ph -> ( ( ps /\ th /\ et ) <-> ( ch /\ ta /\ ze ) ) ) $ { apply ~3anbi123d { use equality } { use equality } { use equality } }
		$ ( ph -> ( ( ps \/ th \/ et ) <-> ( ch \/ ta \/ ze ) ) ) $ { apply ~3orbi123d { use equality } { use equality } { use equality } }
		$ ( ph -> ( A. x ps <-> A. x ch ) ) $ { apply ~albid { use equality } }
		$ ( ph -> ( A. x e. A ps <-> A. x e. A ch ) ) $ { apply ~ralbidv { use equality } }
		$ ( ph -> ( A. x e. A ps <-> A. x e. B ps ) ) $ { apply ~raleqdv { use equality } }
		$ ( ph -> ( A. x e. A ps <-> A. x e. B ch ) ) $ { apply ~raleqbidv { use equality } { use equality } }
		$ ( ph -> ( E. x ps <-> E. x ch ) ) $ { apply ~exbid { use equality } }
		$ ( ph -> ( E. x e. A ps <-> E. x e. A ch ) ) $ { apply ~rexbidv { use equality } }
		$ ( ph -> ( E. x e. A ps <-> E. x e. B ps ) ) $ { apply ~rexeqdv { use equality } }
		$ ( ph -> ( E. x e. A ps <-> E. x e. B ch ) ) $ { apply ~rexeqbidv { use equality } { use equality } }
		$ ( ph -> ( A = B <-> C = B ) ) $ { apply ~eqeq1d { use equality } }
		$ ( ph -> ( A = B <-> A = C ) ) $ { apply ~eqeq2d { use equality } }
		$ ( ph -> ( A = B <-> C = D ) ) $ { apply ~eqeq12d { use equality } { use equality } }
		$ ( ph -> ( A e. B <-> C e. B ) ) $ { apply ~eleq1d { use equality } }
		$ ( ph -> ( A e. B <-> A e. C ) ) $ { apply ~eleq2d { use equality } }
		$ ( ph -> ( A e. B <-> C e. D ) ) $ { apply ~eleq12d { use equality } { use equality } }
		$ ( ph -> ( A R B <-> C R B ) ) $ { apply ~breq1d { use equality } }
		$ ( ph -> ( A R B <-> A R C ) ) $ { apply ~breq2d { use equality } }
		$ ( ph -> ( A R B <-> C R D ) ) $ { apply ~breq12d { use equality } { use equality } }
		$ ( ph -> ( A R B <-> A S B ) ) $ { apply ~breqd { use equality } }
		$ ( ph -> ( A R B <-> C S D ) ) $ { apply ~breq123d { use equality } { use equality } { use equality } }

		$ ( ph -> ( A O B ) = ( A P B ) ) $ { apply ~oveqd { use equality } }
		$ ( ph -> ( A O B ) = ( C O B ) ) $ { apply ~oveq1d { use equality } }
		$ ( ph -> ( A O B ) = ( A O C ) ) $ { apply ~oveq2d { use equality } }
		$ ( ph -> ( F ` A ) = ( G ` A ) ) $ { apply ~fveq1d { use equality } }
		$ ( ph -> ( F ` A ) = ( F ` B ) ) $ { apply ~fveq2d { use equality } }
		$ ( ph -> ( F ` A ) = ( G ` B ) ) $ { apply ~fveq12d { use equality } { use equality } }
		$ ( ph -> { x | ps } = { x | ch } ) $ { apply ~abbidv { use equality } }
		$ ( ph -> { x e. A | ps } = { x e. A | ch } ) $ { apply ~rabbidv { use equality } }
		$ ( ph -> { <. x , y >. | ps } = { <. x , y >. | ch } ) $ { apply ~opabbidv { use equality } }

		$ ( ph -> ( F : A --> B <-> G : A --> B ) ) $ { apply ~feq1d { use equality } }
		$ ( ph -> ( F : A --> C <-> F : B --> C ) ) $ { apply ~feq2d { use equality } }
		$ ( ph -> ( F : X --> A <-> F : X --> B ) ) $ { apply ~feq3d { use equality } }
		$ ( ph -> ( F : A --> C <-> G : B --> C ) ) $ { apply ~feq12d { use equality } { use equality } }
		$ ( ph -> ( F : A --> B <-> F : C --> D ) ) $ { apply ~feq23d { use equality } { use equality } }
		$ ( ph -> ( F : A --> C <-> G : B --> D ) ) $ { apply ~feq123d { use equality } { use equality } { use equality } }

		$ ( ph -> ( x e. A |-> B ) = ( x e. C |-> B ) ) $ { apply ~mpteq1d { use equality } }
		$ ( ph -> ( x e. A |-> B ) = ( x e. A |-> C ) ) $ { apply ~mpteq2dv { use equality } }
		$ ( ph -> ( x e. A |-> B ) = ( x e. C |-> D ) ) $ { apply ~mpteq12dv { use equality } { use equality } }

		$ ( ph -> if ( &W1 , &C1 , &C2 ) = if ( &W1 , &C3 , &C2 ) ) $ { apply ~ifeq1d { use equality }  }
		$ ( ph -> if ( &W1 , &C1 , &C2 ) = if ( &W1 , &C1 , &C3 ) ) $ { apply ~ifeq2d { use equality }  }
		$ ( ph -> if ( &W1 , &C1 , &C2 ) = if ( &W1 , &C3 , &C4 ) ) $ { apply ~ifeq12d { use equality }  }
		$ ( ph -> if ( &W1 , &C1 , &C2 ) = if ( &W2 , &C1 , &C2 ) ) $ { apply ~ifbid { use equality }  }
		$ ( ph -> if ( &W1 , &C1 , &C2 ) = if ( &W2 , &C3 , &C2 ) ) $ { apply ~ifbieq1d { use equality }  }
		$ ( ph -> if ( &W1 , &C1 , &C2 ) = if ( &W2 , &C1 , &C3 ) ) $ { apply ~ifbieq2d { use equality }  }
		$ ( ph -> if ( &W1 , &C1 , &C2 ) = if ( &W2 , &C3 , &C4 ) ) $ { apply ~ifbieq12d { use equality }  }

		$ ( ( ( ph /\ X = Y ) /\ ps ) -> &C1 = &C2 ) $ { apply ~syl6eqr { use equality } ! with ~cB s/ $ X $ / $ Y $ / $ &C1 $ }
		$ ( ( ph /\ X = Y ) -> &C1 = &C2 ) $ { apply ~syl6eqr { use equality } ! with ~cB s/ $ X $ / $ Y $ / $ &C1 $ }
		$ ( ( X = Y /\ ph ) -> &C1 = &C2 ) $ { apply ~syl6eqr { use equality } ! with ~cB s/ $ X $ / $ Y $ / $ &C1 $ }
		$ ( X = Y -> &C1 = &C2 ) $ { apply ~syl6eqr { use equality } ! with ~cB s/ $ X $ / $ Y $ / $ &C1 $ }
	}
}

tactics existence ( +V +W )
{ try
	{ apply ~elex }
	{ apply ~elexd { use deduction } }
	{ apply ~ovex }
	{ apply ~ovexd }
	{ match goal 
		$ ( &W1 -> { <. &S1 , &S2 >. | ( ( &S1 e. &C1 /\ &S2 e. &C2 ) /\ &W2 ) } e. _V ) $
		{ apply ~opabex2
			{ use existence }
			{ use existence }
			{ use normalize { use deduction } }
			{ use normalize { use deduction } }
			with
			~cA $ &C1 $
			~cB $ &C2 $
			~cV $ _V $
			~cW $ _V $
		}
		$ ( &W1 -> { <. &S1 , &S2 >. | ( &S1 e. &C1 /\ &S2 e. &C2 /\ &W2 ) } e. _V ) $
		{ apply ~opabex2
			{ use existence }
			{ use existence }
			{ use normalize { use deduction } }
			{ use normalize { use deduction } }
			with
			~cA $ &C1 $
			~cB $ &C2 $
			~cV $ _V $
			~cW $ _V $
		}
		$ ( &W1 -> { <. &S1 , &S2 >. | &W2 } e. _V ) $
		{ apply ~opabex2
			{ use existence }
			{ use existence }
			{ use normalize { use deduction } }
			{ use normalize { use deduction } }
			with
			~cA +V
			~cB +W
			~cV $ _V $
			~cW $ _V $
		}
		$ ( ph -> &C1 e. _V ) $
		{ find
			!
			$ &C1 = ( &C2 ` &C3 ) $
			{ apply ~a1i 
				{ apply ~eqeltri
					!
					{ apply ~fvex } 
					with
					~cB $ ( &C2 ` &C3 ) $
				}
			}
		}
	}
}

tactics definition ( @T1 @T2 @T3 )
{ match goal
	$ ( &W1 -> ( &C1 ` &C2 ) = &C3 ) $
	{ find
		!
		$ &C1 = ( &S1 e. &C4 |-> &C5 ) $
		{ apply ~fvmptd
			{ apply ~a1i ! }
			{ use equality }
			@T1
			@T2
			with
			~vx $ &S1 $
			~cB $ &C5 $
			~cD $ &C4 $
			~cV $ _V $
		}
	}
	$ ( &W1 -> ( &C1 &C2 &C3 ) = &C4 ) $
	{
		find
		!
		$ &C2 = ( &S1 e. &C5 , &S2 e. &C6 |-> &C7 ) $
		{ apply ~ovmpt2d
			{ apply ~a1i ! }
			{ use normalize { use equality } }
			@T1
			@T2
			@T3
			with
			~vx $ &S1 $
			~vy $ &S2 $
			~cC $ &C5 $
			~cD $ &C6 $
			~cR $ &C7 $
			~cX $ _V $
		}
	}
	$ ( &W1 -> ( &C1 &C2 &C3 <-> &W2 ) ) $
	?
}

tactics deduction_apply ( ≈THM @T )
{ match statement ≈THM
	$ ( &W1 -> ( &W2 /\ &W3 ) ) $
	{ match goal 
		$ ( &W4 -> &W2 ) $ { apply ~syl { use deduction } { apply ~simpld @T with ~wch $ &W3 $ } with ~wps $ &W1 $ }
		$ ( &W4 -> &W3 ) $ { apply ~syl { use deduction } { apply ~simprd @T with ~wch $ &W2 $ } with ~wps $ &W1 $ }
	}
	$ ( &W1 -> &W2 ) $
	{ match goal 
		$ ( &W4 -> &W2 ) $
		{ apply ~syl { use deduction } @T with ~wps $ &W1 $ }
	}
}

// Prove that an expression is a real number, deduction version
tactics reals_closure ()
{ try
	{ apply ~a1i ! }
	{ use deduction }
	{ match goal
		$ ( &W1 -> &C1 e. RR ) $ { match $ &C1 $
			$ -u &C2 $ { apply ~renegcld { use reals_closure } }
			$ ( &C2 + &C3 ) $ { apply ~readdcld { use reals_closure } { use reals_closure } }
			$ ( &C2 - &C3 ) $ { apply ~resubcld { use reals_closure } { use reals_closure } }
			$ ( &C2 x. &C3 ) $ { apply ~remulcld { use reals_closure } { use reals_closure } }
			$ ( &C2 / 2 ) $ { apply ~rehalfcld { use reals_closure } }
			$ ( &C2 / &C3 ) $ { apply ~redivcld { use reals_closure } { use reals_closure } { use deduction } }
		}
		$ &C1 e. RR $ !
	}
}

// Prove an example theorem
proof ~rummex1
{ use reals_closure }

// 
proof ~inftmrel
{ apply ~syl6eqss
	{ use definition { use existence } { use existence } }
	{ apply ~opabssxp }
	with ~cB $ { <. x , y >. | ( ( x e. B /\ y e. B ) /\ ( ( 0g ` W ) ( lt ` W ) x /\ A. n e. NN ( n ( .g ` W ) x ) ( lt ` W ) y ) ) } $
}

proof ~ellimc
{ apply ~bitrd
	{ subgoal 
		{ use deduction_apply ~limcfval { apply ~limcfval { use deduction } { use deduction } } }
		$ ( ph -> ( F limCC B ) = { y | ( z e. ( A u. { B } ) |-> if ( z = B , y , ( F ` z ) ) ) e. ( ( J CnP K ) ` B ) } ) $
		{ use equality }
	}
	{ apply ~syl
		{ use deduction_apply ~limcvallem { apply ~limcvallem ! ! ! with ~vz $ z $ } }
		{ apply ~elab3g { use equality } }
		with ~wps $ ( G e. ( ( J CnP K ) ` B ) -> C e. CC ) $
	}
	with ~wch $ C e. { y | ( z e. ( A u. { B } ) |-> if ( z = B , y , ( F ` z ) ) ) e. ( ( J CnP K ) ` B ) } $
}

proof ~ajfval
{ apply ~syl5eq ! { use definition { use deduction } { use deduction } { use existence $ ( Y ^m X ) $ $ ( X ^m Y ) $ } } with ~cB $ ( U adj W ) $ }
